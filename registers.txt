flags:
oglz_dtxx

overflow
greater
less
zero
direction
trap

(hidden $ip and $flags)

000 - $ac      - accumulator
001 - $ab [u8]
010 - $bp      - base pointer (might be used as temporary stack pointer in future, in use with enter and leave)
011 - $sp      - stack pointer (affected by push, pop, call, ret)
100 - $ba      - b-accumulator
101 - $bb [u8]
110 - $sr      - source (affected by smv)
111 - $ds      - destination (affected by smv)

enter:
push $bp
load $bp, $sp

leave:
load $sp, $bp
pop $bp

~ - wide
[] - indirection
$ - register

arith $reg, $reg/(~)[location]

load $r1, $reg/(~)imm/(~)[~imm|$reg]
  - loads into $r1 the value in 2nd arg
str $r1, $reg/(~)imm/(~)[~imm|$reg]
  - stores a value from $r1 into location in 2nd arg

load $ac, [400] <-> str $ac, 400

jmp snd
ret snd

smv ("string mov") (moves value from [$sr] to [$ds] and {if flag(d) increments else decrements} $sr and $ds afterwards)

arg types:
 01:
$r        : rrr0_xxxx

 11:
$r, $R       : rrr1_0RRR
$r, [$R]     : rrr1_1RRR
$r, imm      : rrr0_0xxx imm_{size of $r}            # xxx -> Sss; follow as: {if S then imm=ss_{size of $r} else imm_{size of $r}}
$r, [$R s of]: rrr0_11RR Rsoo_oooo
$r, [~loc]   : rrr0_10xx loc_short as {size of $r}

 10:
$R           : 0RRR_xxxx
imm          : 10wx_xxxx imm_{if w then short else byte}           # Same ideas as above
(~)[loc]     : 110w_xxxx loc_short as {if w then short else byte}  # Same ideas as above
(~)[$R]      : 111w_0RRR as {if w then short else byte}
(~)[$R s of] : 111w_1RRR as {if w then short else byte} xsoo_oooo

 (s = +, - = 0, 1) # s indicates whether it's negative
of =
  if s +:
    oo_oooo as short + 1
  else:
    -(oo_oooo as short + 1)
(range: [-64, +64])

# Future proposals

keep current system, but add
4 extra splittable general purpose
registers only accesible through these
extra opreand modes:

 100:
$r, $R : rrrr_RRRR

 101:
copy of 11, but it only uses the extra registers

# Future proposals 2

Floating point
