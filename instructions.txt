REGS:
0 zero (both sizes)
1 al   (byte)
2 ah   (byte)
3 bl   (byte)
4 a    (wide)
5 b    (wide)
6 x    (wide)
7 y    (wide)

OPERAND | SIZE | PURPOSE
r       | 4 b  | a register, (can be followed by another r)
R       | 8 b  | a register or an immediate number from 1 up to and including 247 (encoded as 0x08 to 0xff)
br      | 2 b  | a byte register (zero, al, ar, bl)
w       | 16 b | a wide immediate
h       | 12 b | a 12-bit immediate (0-4095 or -2048 to 2047)
b       | 8 b  | a byte immediate

INSTRUCION         | OPCODE | DESCRIPTION
null               | 00     | invalid instruction, triggers invalid opcode fault (so do all opcodes not mentioned here)
...                | 01-08  | ...
write R            | 09     | write to out port (used for simple I/O)
halt               | 0a     | halts processor, triggers halt fault
read r             | 0b     | read from in port (used for simple I/O)
...                | 0c-1f  | ...
nop                | 20     |
push R             | 21     |
call w             | 22     |
jmp w              | 23     |
ret b              | 24     |
pop r              | 25     |
ldstk r, h         | 26     | Load into r values at stack pointer offset of h
store r1, r2, R    | 27     | Write value of R to memory at location [r1 + r2]
ststk h, r         | 28     | Write value of r to stack offset h
load r1, r2, r3    | 29     | Load into r1 the value at location in memory [r2 + r3]
jez w              | 2a     |
jlt w              | 2b     |
jle w              | 2c     |
jgt w              | 2d     |
jge w              | 2e     |
jnz w              | 2f     |
jo  w              | 30     |
jno w              | 31     |
jb,jc w            | 32     |
jae,jnc w          | 33     |
ja  w              | 34     |
jbe w              | 35     |
...                | 36..40 | funny stuff
add r1, r2, R      | 41     | r1 = r2 + R
sub r1, r2, R      | 42     | r1 = r2 - R
and r1, r2, R      | 43     | r1 = r2 & R
or  r1, r2, R      | 44     | r1 = r2 | R
xor r1, r2, R      | 45     | r1 = r2 ^ R
mul r1, r2, r3, r4 | 46     | r2, r1 = r3 * r4 (r2 has the upper bytes)
bmul r1, br2, br3  | 47     | r1(wide) = br2(byte) * br3(byte)
div r1, r2, r3, r4 | 48     | r1 = r3 / r4; r2 = r3 % r4
