BYTE_REGS:
0 r0b   zero
1 r1l   correspond to least significant portion of r1
2 r1h   correspond to most  significant portion of r1
3 r2l   correspond to least significant portion of r2
4 r2h   correspond to most  significant portion of r2
5 r3l   correspond to least significant portion of r3
6 r3h   correspond to most  significant portion of r3
7 r4l   correspond to least significant portion of r4
8 r4h   correspond to most  significant portion of r4
9 r5l   correspond to least significant portion of r5
a r5h   correspond to most  significant portion of r5
b r6b   least significant portion of r6, most significant portion zeroes on writes
c r7b   least significant portion of r7, most significant portion zeroes on writes
d r8b   least significant portion of r8, most significant portion zeroes on writes
e r9b   least significant portion of r9, most significant portion zeroes on writes
f r10b  least significant portion of r10, most significant portion zeroes on writes

WIDE_REGS:
0 r0    zero
1 r1    byte portions fully accessible
2 r2    byte portions fully accessible
3 r3    byte portions fully accessible
4 r4    byte portions fully accessible
5 r5    byte portions fully accessible
6 r6    high byte zeroes
7 r7    high byte zeroes
8 r8    high byte zeroes
9 r9    high byte zeroes
a r10   high byte zeroes
b rs    stack pointer
c rl    link pointer (location of instruction after last `call`)
d rb    base pointer (unused for now)
e rp    page table pointer (unused for now)
f rh    trap handler pointer

OPERAND | SIZE | PURPOSE
br      | 4 b  | a byte register, (can be followed by another r)
wr      | 4 b  | a wide register, (can be followed by another r)
o       | 4 b  | options, instruction-dependant
w       | 16 b | a wide immediate
b       | 8 b  | a byte immediate

trailing 4 bits must be zero

INSTRUCTION            | OPCODE | DESCRIPTION
null                   | 00     | invalid instruction, triggers invalid opcode trap (so do all opcodes not mentioned here)
...                    | 01-09  | ...
halt                   | 0a     | triggers halt trap
ctf                    | 0b     | clear trap flag
...                    | 0c     | ...
reth                   | 0d     | returns from trap handler, clears trap flag
...                    | 0e-1f  | ...
nop                    | 20     |
push br                | 21     |
push wr                | 22     |
pop br                 | 23     |
pop wr                 | 24     |
call w                 | 25     | Write next instruction location to rl and jumps to w
ret b                  | 26     | Add b to stack pointer and jump to rl (returns from sub-routine) (this is shorter than `jmp rl`)
store wr1, w, br2      | 27     | Write byte in r2 to memory at location [r1 + w]
store wr1, w, wr2      | 28     | Write wide in r2 to memory at location [r1 + w] (in little-endian format)
store wr1, wr2, br3    | 29     | Write byte in r3 memory at location [r1 + r2]
store wr1, wr2, wr3    | 2a     | Write wide in r3 memory at location [r1 + r2] (in little-endian format)
load br1, wr2, w       | 2b     | Load byte into r1 from location in memory [r2 + w]
load wr1, wr2, w       | 2c     | Load wide into r1 from location in memory [r2 + w] (in little-endian format)
load br1, wr2, wr3     | 2d     | Load byte into r1 from location in memory [r2 + r3]
load wr1, wr2, wr3     | 2e     | Load wide into r1 from location in memory [r2 + r3] (in little-endian format)
jez w                  | 2f     |
jlt w                  | 30     |
jle w                  | 31     |
jgt w                  | 32     |
jge w                  | 33     |
jnz w                  | 34     |
jo  w                  | 35     |
jno w                  | 36     |
jb,jc w                | 37     |
jae,jnc w              | 38     |
ja  w                  | 39     |
jbe w                  | 3a     |
...                    | 3b-3e  | funny stuff
ldi br, b              | 3f     | load immediate into register
ldi wr, w              | 40     | load immediate into register
jmp w                  | 40     | ldi 0000_0001, w (jump to immediate)
jmp wr                 | 40     | ldi wr_0001 (wr!=0), 0  (jump to register, w needs to be 0)
add br1, br2, br3      | 41     | r1 = r2 + r3
add wr1, wr2, wr3      | 42     | r1 = r2 + r3
sub br1, br2, br3      | 43     | r1 = r2 - r3
sub wr1, wr2, wr3      | 44     | r1 = r2 - r3
and br1, br2, br3      | 45     | r1 = r2 & r3
and wr1, wr2, wr3      | 46     | r1 = r2 & r3
or  br1, br2, br3      | 47     | r1 = r2 | r3
or  wr1, wr2, wr3      | 48     | r1 = r2 | r3
xor br1, br2, br3      | 49     | r1 = r2 ^ r3
xor wr1, wr2, wr3      | 4a     | r1 = r2 ^ r3
shl br1, br2, br3      | 4b     | r1 = r2 << r3
shl wr1, wr2, wr3      | 4c     | r1 = r2 << r3
asr br1, br2, br3      | 4d     | r1 = r2 >> r3 (arithmetic, sign bit (most significant) is copied to the right)
asr wr1, wr2, wr3      | 4e     | r1 = r2 >> r3 (arithmetic, sign bit (most significant) is copied to the right)
lsr br1, br2, br3      | 4f     | r1 = r2 >> r3 (logical)
lsr wr1, wr2, wr3      | 50     | r1 = r2 >> r3 (logical)
div br1, br2, br3, br4 | 51     | r1 = r3 / r4; r2 = r3 % r4
div wr1, wr2, wr3, wr4 | 52     | r1 = r3 / r4; r2 = r3 % r4
mul br1, br2, br3, br4 | 53     | r2, r1 = r3 * r4 (r2 has the upper bytes)
mul wr1, wr2, wr3, wr4 | 54     | r2, r1 = r3 * r4 (r2 has the upper bytes)
